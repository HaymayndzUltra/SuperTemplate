#!/usr/bin/env python3
"""Prerequisite validation for Protocol 12 Quality Audit (Gate 4)."""

from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List

WORKSPACE_ROOT = Path(".artifacts/quality-audit")
RELATED_DIRECTORIES = [
    WORKSPACE_ROOT,
    Path(".artifacts/review-code"),
    Path(".artifacts/review-security"),
    Path(".artifacts/review-architecture"),
]
RELATED_SCRIPTS = [
    "scripts/collect_change_context.py",
    "scripts/aggregate_coverage.py",
    "scripts/validate_gate_4_pre_audit.py",
    "scripts/validate_gate_4_reporting.py",
    "scripts/aggregate_evidence_4.py",
    "scripts/run_protocol_4_gates.py",
]
ARTIFACT_TEMPLATES: Dict[str, str] = {
    ".artifacts/quality-audit/ci-test-results.json": json.dumps(
        {"workflow": "ci-test.yml", "status": "pending", "summary": {}}, indent=2
    )
    + "\n",
    ".artifacts/quality-audit/ci-lint-results.json": json.dumps(
        {"workflow": "ci-lint.yml", "status": "pending", "summary": {}}, indent=2
    )
    + "\n",
    ".artifacts/quality-audit/ci-workflow-log.txt": (
        "# CI Workflow Log\n\nAwaiting workflow execution details.\n"
    ),
    ".artifacts/quality-audit/coverage-report.json": json.dumps(
        {"overall": 0.0, "modules": []}, indent=2
    )
    + "\n",
    ".artifacts/quality-audit/coverage-metadata.yaml": (
        "generated: \nthreshold: 0\nnotes: Coverage metadata placeholder\n"
    ),
    ".artifacts/quality-audit/change-context.json": json.dumps(
        {"summary": "pending", "files": []}, indent=2
    )
    + "\n",
    ".artifacts/quality-audit/mode-resolution.json": json.dumps(
        {"requested_mode": None, "resolved_protocol": None, "status": "pending"},
        indent=2,
    )
    + "\n",
    ".artifacts/quality-audit/protocol-manifest.json": json.dumps(
        {"protocol": None, "hash": None, "status": "pending"}, indent=2
    )
    + "\n",
    ".artifacts/quality-audit/execution-log.md": (
        "# Specialized Protocol Execution Log\n\nDocument delegated steps and outcomes here.\n"
    ),
    ".artifacts/quality-audit/audit-findings.json": json.dumps(
        {"findings": [], "summary": {}}, indent=2
    )
    + "\n",
    ".artifacts/quality-audit/finding-summary.csv": (
        "severity,count\n"
    ),
    ".artifacts/quality-audit/quality-audit-manifest.json": json.dumps(
        {"package": "QUALITY-AUDIT-PACKAGE.zip", "status": "pending"}, indent=2
    )
    + "\n",
}
ZIP_PLACEHOLDER = WORKSPACE_ROOT / "QUALITY-AUDIT-PACKAGE.zip"


def _ensure_file(path: Path, payload: str) -> str:
    path.parent.mkdir(parents=True, exist_ok=True)
    if not path.exists():
        path.write_text(payload, encoding="utf-8")
        return "created"
    return "exists"


def _ensure_zip(path: Path) -> str:
    if path.exists():
        return "exists"
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("wb") as fh:
        fh.write(b"Placeholder package generated by prerequisite validator.\n")
    return "created"


def _check_scripts(scripts: List[str]) -> List[str]:
    missing: List[str] = []
    for script in scripts:
        if not Path(script).exists():
            missing.append(script)
    return missing


def main() -> int:
    artifacts: List[Dict[str, str]] = []

    for directory in RELATED_DIRECTORIES:
        directory.mkdir(parents=True, exist_ok=True)

    for path, payload in ARTIFACT_TEMPLATES.items():
        status = _ensure_file(Path(path), payload)
        artifacts.append({"artifact": path, "status": status})

    artifacts.append({"artifact": str(ZIP_PLACEHOLDER), "status": _ensure_zip(ZIP_PLACEHOLDER)})

    missing_scripts = _check_scripts(RELATED_SCRIPTS)
    report = {
        "protocol": "12",
        "gate": "4",
        "generated_at": datetime.utcnow().isoformat() + "Z",
        "workspace": str(WORKSPACE_ROOT),
        "artifacts": artifacts,
        "missing_scripts": missing_scripts,
        "status": "pass" if not missing_scripts else "warning",
    }

    print(json.dumps(report, indent=2))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
