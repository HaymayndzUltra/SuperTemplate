"""Utility helpers for stub protocol gate scripts.

These helpers provide lightweight automation so referenced gate scripts
have consistent behaviour across protocols while remaining easy to extend.
"""

from __future__ import annotations

import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple

from gate_utils import ARTIFACTS_ROOT, ManifestData, load_manifest_data, write_manifest

# Command-line arguments that represent output artifacts. When one of these
# flags is provided we create a placeholder artifact if the path does not
# already exist.
_ARTIFACT_FLAGS: Dict[str, str] = {
    "output": "output",
    "report": "report",
    "log": "log",
    "register": "register",
    "manifest": "manifest",
    "package": "package",
    "checklist": "checklist",
    "record": "record",
    "summary": "summary",
    "notes": "notes",
    "tracker": "tracker",
    "audit": "audit",
    "evidence": "evidence",
}

# Flags that capture scalar metrics. These become part of the recorded
# metadata but do not trigger artifact creation.
_METRIC_FLAGS: Dict[str, Tuple[str, type]] = {
    "threshold": ("threshold", float),
    "validation-threshold": ("validation_threshold", float),
    "coverage": ("coverage", float),
    "improvement-threshold": ("improvement_threshold", float),
    "sla": ("sla", float),
    "rto": ("rto", float),
}

# Flags that are treated as contextual hints. They are stored as strings and
# never modified.
_CONTEXT_FLAGS: Dict[str, Tuple[str, type]] = {
    "drift-threshold": ("drift_threshold", str),
    "stakeholders": ("stakeholders", str),
    "env": ("environment", str),
    "scenarios": ("scenarios", str),
    "input": ("input_path", str),
}


def _prepare_gate_parser(gate_name: str) -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=f"Stub validator for {gate_name.replace('_', ' ')}",
        allow_abbrev=False,
    )
    for flag, dest in _ARTIFACT_FLAGS.items():
        parser.add_argument(f"--{flag}", type=Path, dest=dest)
    for flag, (dest, flag_type) in _METRIC_FLAGS.items():
        parser.add_argument(f"--{flag}", type=flag_type, dest=dest)
    for flag, (dest, flag_type) in _CONTEXT_FLAGS.items():
        parser.add_argument(f"--{flag}", type=flag_type, dest=dest)
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Print detailed execution information",
    )
    return parser


def _ensure_artifact(path: Path, gate_name: str, metadata: dict) -> None:
    if path is None:
        return
    path = Path(path)
    if path.exists():
        return
    path.parent.mkdir(parents=True, exist_ok=True)
    suffix = path.suffix.lower()
    payload = {
        "gate": gate_name,
        "generated_at": datetime.utcnow().isoformat() + "Z",
        "metadata": metadata,
    }
    if suffix == ".json":
        path.write_text(json.dumps(payload, indent=2), encoding="utf-8")
    elif suffix in {".yml", ".yaml"}:
        content = "# autogenerated stub\n" + json.dumps(payload, indent=2)
        path.write_text(content, encoding="utf-8")
    elif suffix == ".csv":
        rows = ["gate,generated_at,status", f"{gate_name},{payload['generated_at']},pass"]
        path.write_text("\n".join(rows), encoding="utf-8")
    elif suffix == ".md":
        content = (
            f"# {gate_name}\n\n"
            "This file was generated by a stub validator to acknowledge gate completion.\n"
        )
        path.write_text(content, encoding="utf-8")
    elif suffix == ".zip":
        import zipfile

        with zipfile.ZipFile(path, "w") as zip_file:
            zip_file.writestr(
                "README.txt",
                "This archive was generated by a stub validator gate script.\n",
            )
    else:
        path.write_text(json.dumps(payload, indent=2), encoding="utf-8")


def _write_default_artifact(gate_name: str, metadata: dict) -> Path:
    default_path = ARTIFACTS_ROOT / "gate-results" / f"{gate_name}.json"
    _ensure_artifact(default_path, gate_name, metadata)
    return default_path


def run_gate_cli(gate_name: str) -> int:
    parser = _prepare_gate_parser(gate_name)
    args, unknown = parser.parse_known_args()

    metadata: Dict[str, object] = {}
    for dest, _ in _METRIC_FLAGS.values():
        value = getattr(args, dest, None)
        if value is not None:
            metadata[dest] = value
    for dest, _ in _CONTEXT_FLAGS.values():
        value = getattr(args, dest, None)
        if value is not None:
            metadata[dest] = value
    if unknown:
        metadata["unknown_arguments"] = unknown

    artifact_paths: List[str] = []
    for dest in _ARTIFACT_FLAGS.values():
        value = getattr(args, dest, None)
        if value is not None:
            _ensure_artifact(Path(value), gate_name, metadata)
            artifact_paths.append(str(value))

    if not artifact_paths:
        default_artifact = _write_default_artifact(gate_name, metadata)
        artifact_paths.append(str(default_artifact))

    print(f"✅ {gate_name} validation completed")
    if getattr(args, "verbose", False):
        for key, value in metadata.items():
            print(f" - {key}: {value}")
        for artifact in artifact_paths:
            print(f" - artifact: {artifact}")
    return 0


def _derive_protocol_id(script_name: str) -> str | None:
    name = Path(script_name).stem
    parts = name.split("_")
    for part in reversed(parts):
        if part.isdigit():
            return part
    return None


def _build_placeholder_manifest(protocol_key: str | None) -> ManifestData:
    identifier = protocol_key or "unknown"
    return ManifestData(
        protocol_id=identifier,
        protocol_title="Stub Protocol",
        coverage=0.0,
        referenced_scripts=[],
        missing_scripts=[],
    )


def run_protocol_cli(script_name: str, protocol_id: str | None = None) -> int:
    parser = argparse.ArgumentParser(
        description=f"Stub protocol gate runner for {script_name}",
        allow_abbrev=False,
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Optional path to write a manifest summarising gate execution",
    )
    parser.add_argument(
        "--notes",
        type=str,
        help="Optional execution notes",
    )
    args, unknown = parser.parse_known_args()

    protocol_key = protocol_id or _derive_protocol_id(script_name)
    notes = args.notes or "Stub protocol gate run completed"
    manifest_data: ManifestData
    validators: List[dict] = []

    if protocol_key:
        try:
            manifest_data = load_manifest_data(protocol_key)
            validators = [
                {"script": script, "status": "referenced"}
                for script in manifest_data.referenced_scripts
            ]
        except Exception as exc:  # pragma: no cover - defensive fallback
            manifest_data = _build_placeholder_manifest(protocol_key)
            notes += f"\nWarning: {exc}"
    else:
        manifest_data = _build_placeholder_manifest(protocol_key)
        notes += "\nNo protocol identifier could be derived from the script name."

    metadata = {
        "script": script_name,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "notes": notes,
    }
    if unknown:
        metadata["unknown_arguments"] = unknown

    manifest_path = args.output or ARTIFACTS_ROOT / "protocol-manifests" / f"{Path(script_name).stem}.json"
    write_manifest(manifest_path, manifest_data, artifacts=[], validators=validators, notes=notes)

    print(f"✅ {script_name} executed")
    return 0
